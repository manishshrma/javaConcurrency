
JVM is part of JRE and JRE is part of JDk

JVM(Java Virtual Machine) acts as a run-time engine to run Java applications. JVM is the one that actually
calls the main method present in a java code. JVM is a part of JRE(Java Runtime Environment).
Java applications are called WORA (Write Once Run Anywhere). This means a programmer can develop Java code
on one system and can expect it to run on any other Java-enabled system without any adjustment.
This is all possible because of JVM.
When we compile a .java file, .class files(contains byte-code) with the same class names present in .java
file are generated by the Java compiler. This .class file goes into various steps when we run it.
These steps together describe the whole JVM.
Class Loader system mainly responsible for
It is mainly responsible for three activities.
1.Loading
2.Linking
3.Initialization

////////////////Loading:////////////
 The Class loader reads the “.class” file, generate the corresponding binary data and save it in
the method area which is part of JVM memory(see pic). For each “.class” file, JVM stores the
following information in the method area.
1.The fully qualified name of the loaded class and its immediate parent class.
2.Whether the “.class” file is related to Class or Interface or Enum.
3.Modifier, Variables and Method information etc.
All these information(1,2,3) are stored in .class object thus this .class object further goes to the
heap memory(part of JVM)

----summarize----
suppose you compile your student.java file and customer.java file. compiler generate the
student.class and customer.class  file in the directory. when you pass this file to the class loader
(present in JVM) it read that file and generate data (consider 1,2,3 point) and create an class Class object
in the method area(part of JVM). and further this object goes in the heap memory(part of JVM) where this
object get stored

/////////////////Linking: /////////////
Performs verification, preparation, and (optionally) resolution.
******Verification********:
It ensures the correctness of the .class file i.e. it checks whether
this file is properly formatted and generated by a valid compiler or not. If verification
fails, we get run-time exception java.lang.VerifyError. This activity is done by the component
ByteCodeVerifier. Once this activity is completed then the class file is ready for compilation.

********Preparation*********:
JVM allocates memory for class variables and initializing the memory to default values.

******Resolution*********:
It is the process of replacing symbolic references from the type with direct references.
It is done by searching into the method area to locate the referenced entity.

//////////////////////////Initialization:////////////////////
 In this phase, all static variables are assigned with their values defined in the code and
static block(if any). This is executed from top to bottom in a class and from parent to child in the class
hierarchy.

//////////////There are 3 class loader//////////

1. Bootstrap class loader
Every JVM implementation must have a bootstrap class loader, capable of loading trusted classes
 It loads core java API classes present in the “JAVA_HOME/jre/lib” directory.

2.Extension class laoder
It is a child of the bootstrap class loader. It loads the classes present in the extensions directories
“JAVA_HOME/jre/lib/ext”(Extension path) or any other directory specified by the java.ext.dirs
system property

3.System/Application class loader:
It is a child of the extension class loader. It is responsible to load classes from the application classpath.
It internally uses Environment Variable which mapped to java.class.path.
---------------------------------------------------------------------------

Suppose class loadere load the Test.class file in the method area, but inside the Test.class file i
have creted the Student s=new Student(); then student.class file must be loaded, if class loader not
loaded it, then JVM request the class loader subsystem to laod the .class file. class loader subsystem has
3 class loader it will start from System/Application class loader,then delegate the request to the
extension class laoder which in turn to the bootstrap class loader. Now bootstrap class loader search for
in bootstrap class path. If not found anywher give classNotFound


